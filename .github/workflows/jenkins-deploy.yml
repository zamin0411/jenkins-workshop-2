name: Deploy to Jenkins

on:
  push:
    branches: [ main, develop ]
    paths:
      - 'template2/**'
      - 'ansible/**'
      - 'Jenkinsfile'
      - 'docker-compose.yml'
  pull_request:
    branches: [ main ]
    paths:
      - 'template2/**'
      - 'ansible/**'
      - 'Jenkinsfile'
      - 'docker-compose.yml'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'staging'
        type: choice
        options:
        - staging
        - production
      force_deploy:
        description: 'Force deployment even if no changes'
        required: false
        default: false
        type: boolean

env:
  JENKINS_JOB_NAME: workshop2
  JENKINS_URL: ${{ secrets.JENKINS_URL }}

jobs:
  validate-changes:
    runs-on: ubuntu-latest
    outputs:
      should-deploy: ${{ steps.changes.outputs.should-deploy }}
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        
    - name: Check for relevant changes
      id: changes
      run: |
        if [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ "${{ github.event.inputs.force_deploy }}" = "true" ]; then
          echo "should-deploy=true" >> $GITHUB_OUTPUT
          echo "Force deployment requested"
        elif [ "${{ github.event_name }}" = "pull_request" ]; then
          echo "should-deploy=true" >> $GITHUB_OUTPUT
          echo "Pull request - will trigger Jenkins"
        else
          # Check if there are changes in relevant paths
          if git diff --name-only HEAD~1 HEAD | grep -E '^(template2/|ansible/|Jenkinsfile|docker-compose\.yml)'; then
            echo "should-deploy=true" >> $GITHUB_OUTPUT
            echo "Relevant changes detected"
          else
            echo "should-deploy=false" >> $GITHUB_OUTPUT
            echo "No relevant changes detected"
          fi
        fi

  trigger-jenkins:
    needs: validate-changes
    if: needs.validate-changes.outputs.should-deploy == 'true'
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up environment variables
      run: |
        echo "JENKINS_JOB_NAME=${{ env.JENKINS_JOB_NAME }}" >> $GITHUB_ENV
        echo "BRANCH_NAME=${{ github.ref_name }}" >> $GITHUB_ENV
        echo "GIT_COMMIT=${{ github.sha }}" >> $GITHUB_ENV
        echo "GIT_URL=${{ github.server_url }}/${{ github.repository }}" >> $GITHUB_ENV
        echo "BUILD_CAUSE=github-actions" >> $GITHUB_ENV
        echo "DEPLOY_ENVIRONMENT=${{ github.event.inputs.environment || 'staging' }}" >> $GITHUB_ENV
        
    - name: Trigger Jenkins Job
      id: trigger
      uses: davidbrockman/trigger-jenkins-job@v1
      with:
        jenkins-url: ${{ secrets.JENKINS_URL }}
        jenkins-user: ${{ secrets.JENKINS_USER }}
        jenkins-token: ${{ secrets.JENKINS_TOKEN }}
        job-name: ${{ env.JENKINS_JOB_NAME }}
        parameters: |
          BRANCH_NAME=${{ env.BRANCH_NAME }}
          GIT_COMMIT=${{ env.GIT_COMMIT }}
          GIT_URL=${{ env.GIT_URL }}
          BUILD_CAUSE=${{ env.BUILD_CAUSE }}
          DEPLOY_ENVIRONMENT=${{ env.DEPLOY_ENVIRONMENT }}
          
    - name: Wait for Jenkins Job
      uses: davidbrockman/wait-for-jenkins-job@v1
      with:
        jenkins-url: ${{ secrets.JENKINS_URL }}
        jenkins-user: ${{ secrets.JENKINS_USER }}
        jenkins-token: ${{ secrets.JENKINS_TOKEN }}
        job-name: ${{ env.JENKINS_JOB_NAME }}
        build-number: ${{ steps.trigger.outputs.build-number }}
        timeout: 1800  # 30 minutes timeout
        
    - name: Get Jenkins Build Status
      id: status
      run: |
        echo "Jenkins job completed successfully"
        echo "Build URL: ${{ env.JENKINS_URL }}/job/${{ env.JENKINS_JOB_NAME }}/${{ steps.trigger.outputs.build-number }}/"
        
    - name: Comment on PR
      if: github.event_name == 'pull_request'
      uses: actions/github-script@v7
      with:
        script: |
          const { data: comments } = await github.rest.issues.listComments({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: context.issue.number,
          });
          
          const botComment = comments.find(comment => 
            comment.user.type === 'Bot' && 
            comment.body.includes('Jenkins Deployment')
          );
          
          const commentBody = `## üöÄ Jenkins Deployment
          
          **Status:** ‚úÖ Success
          **Build:** [#${{ steps.trigger.outputs.build-number }}](${{ env.JENKINS_URL }}/job/${{ env.JENKINS_JOB_NAME }}/${{ steps.trigger.outputs.build-number }}/)
          **Environment:** ${{ env.DEPLOY_ENVIRONMENT }}
          **Commit:** \`${{ github.sha }}\`
          
          The deployment has been triggered successfully.`;
          
          if (botComment) {
            await github.rest.issues.updateComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: botComment.id,
              body: commentBody
            });
          } else {
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: commentBody
            });
          }

  notify-failure:
    needs: [validate-changes, trigger-jenkins]
    if: failure() && needs.validate-changes.outputs.should-deploy == 'true'
    runs-on: ubuntu-latest
    
    steps:
    - name: Notify on failure
      run: |
        echo "‚ùå Jenkins deployment failed"
        echo "Check the Jenkins job for details: ${{ env.JENKINS_URL }}/job/${{ env.JENKINS_JOB_NAME }}/"
